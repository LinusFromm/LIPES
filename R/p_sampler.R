#' Sampler over the M_p-extension
#' @param A Configuration matrix
#' @param y Observation vector
#' @param n.samples Number of samples per chain
#' @param n.chains Number of chains
#' @param n.burnin length of burnin
#' @param B A set of vectors connecting the M_p-extension
#' @param CPLB_idx A set indicating A_2 columns
#' @param x.start Initial point
#' @param p Relaxation limit
#' @param ldelta log(delta) determining epsilon
#'
#' @return Returns a matrix containing the samples over the M_p-extension generated by a hit-and-run algorithm
#' @export
p_sampler <- function(A, y, n.samples = 1e5, n.chains = 4, n.burnin = 1e4, B = NULL, CPLB_idx = NULL, x.start = NULL, p = 0, ldelta = 0){
  n = nrow(A)
  r = ncol(A)

  A = as.matrix(A)
  y = as.integer(y)

  if(is.null(CPLB_idx)){
    CPLB_idx = (n+1):r
  } else if (length(CPLB_idx) != r-n){
    stop("CPLB index has to have length r-n")
  }

  if(is.null(B)){
    B = computeCPLB(A, CPLB_idx)
  }

  if(length(p) == 1){
    p = rep(p, r)
  } else if(length(p) != r){
    stop("p has to have dimension r!")
  }

  if(is.null(x.start)){
    x.start = matrix(0, nrow = n.chains, ncol = r)
    for(i in 1:n.chains)
    {
      x.start[i,] = lpSolve::lp(direction = "min",
                                objective.in = sample(0:1,r,replace = TRUE),
                                const.mat = A,
                                const.dir = "==",
                                const.rhs = y,
                                int.vec = 1:r)$solution
    }
  }
  sample = matrix(0, nrow = n.chains*n.samples, ncol = r+3)

  for(i in 1:n.chains){
    x = x.start[i,]
    for(j in 1:n.burnin){
      x.star = proposePoint_p(x, B, p)
      alpha = calculateAlpha(x, x.star, ldelta)

      u = stats::runif(1,0,1)
      if(u < alpha){
        x = x.star
      }
    }

    sample[(i-1)*n.samples+1,1:length(x)] = x
    sample[(i-1)*n.samples+1,length(x)+1:3] = c(i, 1, (i-1)*n.samples+1)

    for(j in 2:(n.samples)){
      x.star = proposePoint_p(x, B, p)
      alpha = calculateAlpha(x, x.star, ldelta)

      u = stats::runif(1,0,1)
      if(u < alpha){
        x = x.star
      }

      sample[(i-1)*n.samples+j, 1:length(x)] = x
      sample[(i-1)*n.samples+j, length(x)+1:3] = c(i, j, (i-1)*n.samples+j)
    }
  }

  return(sample)
}
