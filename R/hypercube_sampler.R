#' Sampler over the hypercuboid-extension
#' @param A Configuration matrix
#' @param y Observation vector
#' @param n.samples Number of samples per chain
#' @param n.chains Number of chains
#' @param n.burnin length of burnin
#' @param B A set of vectors connecting the M_p-extension
#' @param CPLB_idx A set indicating A_2 columns
#' @param x.start Initial point
#' @param a Hypercuboid bounds
#' @param ldelta log(delta) determining epsilon
#' @param w Negativity weight
#' @param method "MH" Metropolis-Hastings sampler or "Gibbs" Gibbs sampler
#'
#' @return Returns a matrix containing the samples over the M_p-extension generated by a hit-and-run algorithm
#' @export
hypercube_sampler <- function(A, y, n.samples = 1e5, n.chains = 4, n.burnin = 1e4, B = NULL, CPLB_idx = NULL, x.start = NULL, a = 0, ldelta = 0, w = 0, method = "MH"){
  n = nrow(A)
  r = ncol(A)

  A = as.matrix(A)
  y = as.integer(y)

  if(is.null(CPLB_idx)){
    CPLB_idx = (n+1):r
  } else if (length(CPLB_idx) != r-n){
    stop("CPLB index has to have length r-n")
  }

  if(is.null(B)){
    B = computeCPLB(A, CPLB_idx)
  }

  if(length(a) == 1){
    a = rep(a, r)
  } else if(length(a) != r-n){
    stop("p has to have dimension r-n!")
  }

  if(is.null(x.start)){
    x.start = matrix(0, nrow = n.chains, ncol = r)
    for(i in 1:n.chains)
    {
      x.start[i,] = lpSolve::lp(direction = "min",
                                objective.in = sample(0:1,r,replace = TRUE),
                                const.mat = A,
                                const.dir = "==",
                                const.rhs = y,
                                int.vec = 1:r)$solution
    }
  }
  sample = matrix(0, nrow = n.chains*n.samples, ncol = r+3)

  for(i in 1:n.chains){
    x = x.start[i,]
    for(j in 1:n.burnin){
      if(method == "MH"){
        x.star = proposePoint_hypercube(x, B, CPLB_idx, a)
        alpha = calculateAlpha(x, x.star, ldelta, w)

        u = stats::runif(1,0,1)
        if(u < alpha){
          x = x.star
        }
      } else if (method == "Gibbs") {
        x = proposePoint_hypercube_gibbs(x, B, ldelta, w, CPLB_idx, a)
      }
    }

    sample[(i-1)*n.samples+1,1:length(x)] = x
    sample[(i-1)*n.samples+1,length(x)+1:3] = c(i, 1, (i-1)*n.samples+1)

    for(j in 2:(n.samples)){
      if(method == "MH"){
        x.star = proposePoint_hypercube(x, B, CPLB_idx, a)
        alpha = calculateAlpha(x, x.star, ldelta, w)

        u = stats::runif(1,0,1)
        if(u < alpha){
          x = x.star
        }
      } else if(method == "Gibbs"){
        x = proposePoint_hypercube_gibbs(x, B, ldelta, w, CPLB_idx, a)
      }
      sample[(i-1)*n.samples+j, 1:length(x)] = x
      sample[(i-1)*n.samples+j, length(x)+1:3] = c(i, j, (i-1)*n.samples+j)
    }
  }

  return(sample)
}
